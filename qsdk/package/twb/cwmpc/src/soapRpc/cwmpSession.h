
#ifndef _cwmpSession__H
#define _cwmpSession__H
/*----------------------------------------------------------------------*
 * Gatespace
 * Copyright 2006 Gatespace Networks, Inc., All Rights Reserved.
 * Gatespace Networks, Inc. confidential material.
 *----------------------------------------------------------------------*
 * File Name  : cwmpSession.h
 * Description:	Implementation of CPE to ACS session management
 *----------------------------------------------------------------------*
 * $Revision: 1.13 $
 *
 * $Id: cwmpSession.h,v 1.13 2012/05/10 17:38:07 dmounday Exp $
 *----------------------------------------------------------------------*/
#include "../gslib/src/event.h"
#include "../gslib/src/protocol.h"
#include "../gslib/src/wget.h"
#include "xmlTables.h"
#include "rpcMethods.h"
/* Define action completion RPC and post Session pending actions */
/* Flags that are used to indicate RPCs that are pending following the
 * InformResponse and other ACS RPCs. These indicate completion of previously
 * requested actions or are CPE generated requests.
 * The Post session actions are those requested by the ACS RPCs that must
 * be postponed until the session completes. The following details the various
 * uses of the pending actions.
 * I: Schedules an immediate Inform with the EventCode
 * P: Indicates a pending RPC will be sent following Inform, such as TransferComplete
 * C: Indicates a post-session CPE action to be taken based on RPC from ACS
 * E: Must have associated Event code added to eventPolicy table
 * G: A request generated by some other entity in the CPE
 * E*: BOOTSTRAP event is forced on first Inform to new ACS
 * s: The event needs to be saved for the first Inform following the CPE reboot
 */

#define PENDING_REBOOT     0x00000001  /* Cs: set by Reboot RPC */
#define PENDING_CONNREQ    0x00000002  /* IE: connection request received*/
#define PENDING_RESET      0x00000004  /* C: set by FactoryReset RPC */
#define PENDING_DIAGINFORM 0x00000008  /* IE: diagnostic has completed - CPE generated event */
#define PENDING_GETRPC     0x00000010  /* IP: CPE generated request for GetRPCMethods*/
#define PENDING_XFERCOMPL  0x00000040  /* IEPs:Set when upload or download transfer completes  */
#define PENDING_STARTXFER  0x00000080  /* C: set by startTransfer when start transer is pending*/
#define PENDING_REQDOWNLOAD 0x000000100 /*GEP: CPE generated request to send RequestDownload RPC*/
#define PENDING_ACSCHANGE  0x00000200  /* E*: ACS URL was changed by ACS or CPE - pending BOOTSTRAP Inform */
#define PENDING_SENDKICKED 0x00000400  /* GEP: CPE has kicked cwmp to send a Kicked RPC */
#define PENDING_AUTOXFRCMPT 0x000000800 /*GEP: CPE generated request to send AutonomousTransferComplete*/
#define PENDING_VALUECHG    0x000001000 /*IE: value change noticed */

#define PENDING_ANY			0xffffffff  /* used to mask for any pending actions */

/*
 * dlStatus values
 */
#define XFER_PENDING		-2			/* Waiting on WAITINGQ cpeState.dlQ  */
#define XFER_ACTIVE			-1			/* active transfer in progress */
#define XFER_UTILITY		2			/* external transfer utility, curl ,wget, ... */

typedef struct ACSSession {
    char    sessID[12];
    int     holdFlag;	/* ACS hold request flag */
    eHTTPSTATE      eHttpState;
    eAUTHSTATE      eAuthState;
    eNullMsgState   eNullState;
    tWgetInternal   *wio;
    char            *postMsg;
    int             postLth;
    char            *authHdr;
    SessionAuth     sessionAuth;
    int             retryCount;			/* Current ACS connection retry count */
    int             delay;				/* Current retry delay value in msec */
    long			expVal;				/* exponential delay multiplier      */
    RPCRequest      *rpc;
    CookieHdr		*sessionCookie;     /* save Session cookies if not Keep-alive*/
    char			sessACSURL[257];        /* may be changed multiple times by Redirect status */
    int				redirCount;			/* number of redirects this session */
    void			*cpeDLBuf;			/* CPE wrapper supplied download buffer*/
    int				cpeDLBufLth;		/* lth of buffer */
    CBGetBuf		cpeBufCB; 			/* callback function to handle buffer */
} ACSSession;

void cwmpStartACSInform(void);
int  cwmpIsACSSessionActive(void);
#define BLOCK_NEW_SESSION -1
#define UNBLOCK_NEW_SESSION 0
int cwmpSetSessionBlock( int block );
void cwmpSetPending( int actionMask );
void cwmpClearPending( int actionMask);
void cwmpDiagnosticComplete(void);
void cwmpCheckValueChange(void);
void cwmpStartPending(void);
eEState cwmpGetEventState( eEventCode event);
const char *cwmpGetEventName( eEventCode event);
int cwmpGetEventCount(void);
void cwmpAddEvent( eEventCode event );
void cwmpQueueDLRequest( RPCRequest *r, int Q );
RPCRequest *cwmpDQItem(RPCRequest *item, RPCRequest **qHead);
void cwmpSendXfersComplete(void);
#ifdef CONFIG_RPCGETQUEUEDTRANSFERS
int  cwmpGetQueuedTransfersList(XMLWriter *xp );
#endif
#ifdef CONFIG_RPCGETALLQUEUEDTRANSFERS
int  cwmpGetAllQueuedTransfersList(XMLWriter *xp );
#endif
#ifdef CONFIG_RPCSCHEDULEINFORM
void cwmpScheduleInform(void *);
#endif
#if defined(CONFIG_RPCDOWNLOAD)
void cwmpSetDLBufferHandler( int (*cb)(void*, char *, int), char *cpeBuf, int bufLth);
#endif
#ifdef CONFIG_RPCSCHEDULEDOWNLOAD
void cwmpStartWindow(void*);
void cwmpDownloadWindowResume(void);
void cwmpStopDownloadWindowTimers( RPCRequest *r);
#endif
int	 cwmpCancelWaiting(const char *);
#if defined(CONFIG_RPCDOWNLOAD) || defined(CONFIG_RPCUPLOAD)
void cwmpCheckStartTransfer(void*);
#endif
void updateConnection(void *handle);
#endif
